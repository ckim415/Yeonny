프림 알고리즘: 시작 정점을 선택한 후, 정점에 인접한 간선 중 최소 간선으로 연결된 정점을 선택하고, 해당 점점에서 다시 최소 간선으로 연결된 정점을 선택하는 방식으로 최소 신장트리를 확장해가는 방식

1. 크루스칼 알고리즘과 비교
 - 둘다, 탐욕 알고리즘을 기초로 하고 있음
 - 쿠르스칼 알고리즘은 가중치가 가장 작은 edge 부터 선택하면서 MST를 구함
 - 프림 알고리즘은 특정 node에서 시작, 그 node에서 연결된 edge 중 가장 작은 edge을 선택, edge으로 연결된 node들의 edge들 중 가장 작은 edge를 택하는 방식으로 MST를 구함
 
2. 동작 방법 - 간선중심
 - 임의의 정점 선택, '연결된 노드 집합'에 삽입
 - 선택된 정점에 연결된 간선들을 간선 리스트에 삽입
 - 간선 리스트에서 최소 가중치를 갖는 간선부터 추출해서,
  - 해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 이미 있다면, 스킵
  - 해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 없다면, 해당 간선을 선택하고, 해당 간선 정보를 최소 신장 트리에 삽입
 - 추출한 간선은 간선 리스트에서 제거
 - 간선 리스트에 더 이상의 간선이 없을 때까지 반복
 
3. 프림 알고리즘의 시간복잡도
 - 최악의 경우 while문에서 모든 간선에 대해 반복 + min heap 구조를 사용하기 때문에 => O(ElogE)
 
4. 개선된 프림 알고리즘
 - 간선이 아니라 노드를 중심으로 우선순위 큐를 적용하는 방식
  - 초기화 : 정점:key 구조를 만들어 놓고, 특정 정점의 key값은 0, 이외의 정점들의 key값은 무한대로 놓음. 모든 정점:key 값은 우선순위 큐에 넣음
  - 가장 key값이 작은 정점:key를 pop (extract min)
  - 해당 정점의 인접한 정점들에 대해 key 값과 연결된 가중치 값을 비교하여 key 값이 작으면 해당 정점:key 값을 갱신
   - 정점:key 값 갱신시, 우선순위 큐는 최소 key값을 가지는 정점:key를 루트노드로 올려놓도록 재 구성함(decrease key)
 - 개선된 프림 알고리즘 구현시 고려 사항
  - 우선순위 큐(최소힙) 구조에서, 이미 들어가 있는 데이터의 값 변경시, 최소값을 가지는 데이터를 루트노드로 올려놓도록 재구성하는 기능이 필요함
  - 구현 복잡도를 줄이기 위해, heapdict 라이브러리를 통해, 해당 기능을 간단히 구현
  
5. 개선된 프림 알고리즘 시간 복잡도
 - 1. 초기화 : 노드의 갯수 만큼 반복 => O(V)
 - 2. 최소 간선을 추출
  - while문 실행 + keys.popitem()의 시간 복잡도 => O(VlogV)
   - while문은 노드의 갯수만큼 반복 => O(V)
   - keys.popitem() : 최악의 경우 heapdict에 V개의 노드가 들어있음 => O(logV)
 - 3. 키 값을 업데이트 => O(ElogV)
  - for 문 : 간선의 수 만큼 반복 => O(E)
  - for 문 안에서 key 값 변경시 마다 heap 구조 변경 => O(logV)
   - 일반적으로 heap 자료 구조 자체는 본래 heap 내부의 데이터 우선순위 변경시, 최소 우선순위 데이터를 루트노드로 만들어주는 로직은 없음. 이를 decreas key로직으라고 부르고, 해당 로직은 heapdict 라이브러리를 통해 간단히 적용 가능
=> O(V) + O(VlogV) + O(ElogV)
 - O(V)는 큰 영향이 없으므로 삭제, E>V 이므로 
  
  
